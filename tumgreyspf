#!/usr/bin/env python
# vim: ts=3 sw=3 ai
#
#  Log information about incoming SMTP connections.
#
#  Copyright (c) 2004-2013, Sean Reifschneider, tummy.com, ltd.
#  All Rights Reserved
#  <jafo@tummy.com>

import syslog
import os
import sys
import string
import re
import time
import errno
import spf
from subprocess import Popen, PIPE

sys.path.append('/usr/local/lib/tumgreyspf')
import tumgreyspfsupp

syslog.openlog(os.path.basename(sys.argv[0]), syslog.LOG_PID, syslog.LOG_MAIL)
tumgreyspfsupp.set_except_hook()


#########################
def is_loopback(address):
    """
    Checks if a given address is a loopback address.

    :param address: The address to check.
    :return: True if the given address is a loopback IP.
    """
    if address in ['127.0.0.1', '::1'] or address.startswith('127.0.0.'):
        return True

    try:
        import ipaddress
    except ImportError:
        return False

    loopback_cidrs = ['127.0.0.0/8', '::ffff:127.0.0.0/104', '::1/128']
    compare = ipaddress.ip_interface(address).network.overlaps
    for cidr in loopback_cidrs:
        if compare(ipaddress.ip_interface(cidr).network):
            return True

    return False


#############################################
def spf_check(msg_data, config_data, config_global):
    debug_level = config_global.get('debugLevel', 0)
    queue_id = ('QUEUE_ID="%s"' % (msg_data.get('queue_id', '<UNKNOWN>')))
    ip = msg_data.get('client_address')
    if ip is None:
        if debug_level:
            syslog.syslog('spfcheck: No client address, exiting')
        return None, None

    if is_loopback(ip):
        return None, 'SPF check N/A for local connections'

    sender = msg_data.get('sender')
    helo = msg_data.get('helo_name')
    if not sender and not helo:
        if debug_level:
            syslog.syslog('spfcheck: No sender or helo, exiting')
        return None, None

    # if no helo name sent, use domain from sender
    if not helo:
        foo = string.split(sender, '@', 1)
        if len(foo) < 2:
            helo = 'unknown'
        else:
            helo = foo[1]

    # start query
    spf_result = None
    spf_reason = None

    if hasattr(spf, 'check2'):
        #  use the pySPF 2.0/RFC 4408 interface
        try:
            ret = spf.check2(i=ip, s=sender, h=helo)
        except Exception, e:
            header = 'TumGreySPF-Warning: SPF Check failed: %s' % str(e)
            return 'prepend', header

        spf_reason = repr(str(string.strip(ret[1])))
        spf_result = string.strip(ret[0])
        spf_result = spf_result.lower().capitalize()
        if spf_result == 'None':
            #  allow checking to continue on to other checkers if no SPF
            return ((None, None))
        if sender:
            identity = 'identity=mailfrom; '
        else:
            identity = 'identity=helo; '
        spf_detail = (identity +
                      'client-ip=%s; helo=%s; envelope-from=%s; '
                      'receiver=%s; ' % (
                          msg_data.get('client_address', '<UNKNOWN>'),
                          msg_data.get('helo_name', '<UNKNOWN>'),
                          msg_data.get('sender', '<UNKNOWN>'),
                          msg_data.get('recipient', '<UNKNOWN>'),
                      ))
        syslog.syslog('%s: %s; %s' % (spf_reason, queue_id, spf_detail))

        if spf_result == 'Fail':
            return 'reject', '%s SPF Reports: %s' % (queue_id, spf_reason)

        spf_accept_on_perm_error = config_global.get(
            'spfAcceptOnPermError', 1)
        if spf_result == 'Permerror' and not spf_accept_on_perm_error:
            return 'reject', '%s SPF Reports: %s' % (queue_id, spf_reason)

        if spf_result == 'Temperror':
            return 'defer', '%s SPF Reports: %s' % (queue_id, spf_reason)

        header = ('Received-SPF: ' + spf_result + ' (' +
                  spf_reason + ') ' + spf_detail)

        return 'prepend', header
    else:
        #  fall back to older pre-RFC interface
        try:
            ret = spf.check(i=ip, s=sender, h=helo)
        except Exception, e:
            header = 'TumGreySPF-Warning: SPF Check failed: %s' % str(e)
            return 'prepend', header

        spf_result = string.strip(ret[0])
        spf_reason = repr(str(string.strip(ret[2])))

        #  try spfquery
        if not spf_result:
            #  check for spfquery
            spf_query_path = config_global['spfqueryPath']
            if not os.path.exists(spf_query_path):
                if debug_level:
                    syslog.syslog('spfcheck: No spfquery at "%s", exiting'
                                  % spf_query_path)
                return ((None, None))

            # open connection to spfquery
            # https://docs.python.org/2/library/subprocess.html#replacing-functions-from-the-popen2-module
            # fpIn, fpOut = popen2.popen2('%s -file -' % spfqueryPath)
            p = Popen('%s -file -' % spf_query_path, shell=True, stdin=PIPE,
                      stdout=PIPE, close_fds=True)
            fp_in, fp_out = p.stdin, p.stdout
            fp_out.write('%s %s %s\n' % (ip, sender, helo))
            fp_out.close()
            spf_data = fp_in.readlines()
            fp_in.close()
            if debug_level:
                syslog.syslog(
                    'spfcheck: spfquery result: "%s"' % str(spf_data))
            spf_result = string.strip(spf_data[0])
            spf_reason = repr(str(string.strip(spf_data[1])))

        # read result
        if spf_result == 'fail' or spf_result == 'deny':
            syslog.syslog('SPF fail: REMOTEIP="%s" HELO="%s" SENDER="%s" '
                          'RECIPIENT="%s" %s REASON="%s"'
                          % (
                              msg_data.get('client_address', '<UNKNOWN>'),
                              msg_data.get('helo_name', '<UNKNOWN>'),
                              msg_data.get('sender', '<UNKNOWN>'),
                              msg_data.get('recipient', '<UNKNOWN>'),
                              queue_id, spf_reason
                          ))

            return 'reject', '%s SPF Reports: %s' % (queue_id, spf_reason)

    if debug_level:
        syslog.syslog('spfcheck: pyspf result: "%s"' % str(ret))

    return None, None


##################################################
def greylist_check(msg_data, config_data, config_global):
    greylist_dir = config_global['greylistDir']

    ip = msg_data.get('client_address')
    if ip is None:
        return None, None
    ip_bytes = string.split(ip, '.')
    if config_global['ignoreLastByte'] > 0:
        ip_bytes = ip_bytes[:-1]
    ip_path = string.join(ip_bytes, '/')

    if config_global['greylistByIPOnly'] > 0:
        dir = os.path.join(greylist_dir, ip_path)
        path = os.path.join(dir, 'check_file')
    else:
        sender = msg_data.get('sender')
        recipient = msg_data.get('recipient')
        if not sender or not recipient:
            return ((None, None))
        sender = tumgreyspfsupp.quote_address(sender)
        recipient = tumgreyspfsupp.quote_address(recipient)
        dir = os.path.join(greylist_dir, 'client_address', ip_path,
                           'greylist', sender)
        path = os.path.join(dir, recipient)

    allow_time = config_data.get('GREYLISTTIME', 600)

    if not os.path.exists(path):
        if not os.path.exists(dir):
            #  if multiple messages come in at once
            #  it can cause multiple makedirs
            for i in xrange(10):
                try:
                    os.makedirs(dir)
                    break
                except OSError, msg:
                    if msg.errno != errno.EEXIST:
                        raise
                    time.sleep(1)

            # still didn't succeed
            if not os.path.exists(dir):
                syslog.syslog(('ERROR: Could not create directory after '
                               '10 seconds: "%s"') % dir)
                return (
                    'defer', 'Service unavailable, error creating data '
                             'directory.  See /var/log/maillog for more '
                             'information.'
                )

        # create file
        open(path, 'w').close()
        now = time.time()
        release_time = now + allow_time
        os.utime(path, (now, release_time))

        if config_global.get('defaultSeedOnly'):
            syslog.syslog(
                'Training greylisting: REMOTEIP="%s" HELO="%s" '
                'SENDER="%s" RECIPIENT="%s" QUEUEID="%s"'
                % (
                    msg_data.get('client_address', '<UNKNOWN>'),
                    msg_data.get('helo_name', '<UNKNOWN>'),
                    msg_data.get('sender', '<UNKNOWN>'),
                    msg_data.get('recipient', '<UNKNOWN>'),
                    msg_data.get('queue_id', '<UNKNOWN>')
                ))
            return None, None

        syslog.syslog('Initial greylisting: REMOTEIP="%s" HELO="%s" '
                      'SENDER="%s" RECIPIENT="%s" QUEUEID="%s"' % (
                          msg_data.get('client_address', '<UNKNOWN>'),
                          msg_data.get('helo_name', '<UNKNOWN>'),
                          msg_data.get('sender', '<UNKNOWN>'),
                          msg_data.get('recipient', '<UNKNOWN>'),
                          msg_data.get('queue_id', '<UNKNOWN>')
                      ))

        return (
            'defer', 'Service unavailable, greylisted '
                     '(http://projects.puremagic.com/greylisting/).'
        )

    # is it time to allow yet
    release_time = os.stat(path)[8]
    now = time.time()
    os.utime(path, (now, release_time))
    if release_time > now and not config_global.get('defaultSeedOnly'):
        syslog.syslog('Pending greylisting: REMOTEIP="%s" HELO="%s" '
                      'SENDER="%s" RECIPIENT="%s" QUEUEID="%s"' % (
                          msg_data.get('client_address', '<UNKNOWN>'),
                          msg_data.get('helo_name', '<UNKNOWN>'),
                          msg_data.get('sender', '<UNKNOWN>'),
                          msg_data.get('recipient', '<UNKNOWN>'),
                          msg_data.get('queue_id', '<UNKNOWN>')
                      ))

        return 'defer', 'Service unavailable, greylisted.'

    syslog.syslog('Allowed greylisting: REMOTEIP="%s" HELO="%s" SENDER="%s" '
                  'RECIPIENT="%s" QUEUEID="%s"'
                  % (
                      msg_data.get('client_address', '<UNKNOWN>'),
                      msg_data.get('helo_name', '<UNKNOWN>'),
                      msg_data.get('sender', '<UNKNOWN>'),
                      msg_data.get('recipient', '<UNKNOWN>'),
                      msg_data.get('queue_id', '<UNKNOWN>')
                  ))

    return None, None


###################################################
def black_hole_check(msg_data, config_data, config_global):
    black_hole_dir = config_global['blackholeDir']

    ip = msg_data.get('client_address')
    if ip is None:
        return None, None
    ip_path = string.join(string.split(ip, '.'), '/')
    dir = os.path.join(black_hole_dir, 'ips', ip_path)

    recipient = msg_data.get('recipient')
    if not recipient:
        return None, None
    recipient = tumgreyspfsupp.quote_address(recipient)

    #  add blackhole
    recipient_path = os.path.join(black_hole_dir, 'addresses', recipient)
    if os.path.exists(recipient_path):
        if not os.path.exists(dir):
            os.path.makedirs(dir)

    # check for existing blackhole entry
    if os.path.exists(dir):
        syslog.syslog('Blackholed: REMOTEIP="%s" HELO="%s" SENDER="%s" '
                      'RECIPIENT="%s" QUEUEID="%s"'
                      % (
                          msg_data.get('client_address', '<UNKNOWN>'),
                          msg_data.get('helo_name', '<UNKNOWN>'),
                          msg_data.get('sender', '<UNKNOWN>'),
                          msg_data.get('recipient', '<UNKNOWN>'),
                          msg_data.get('queue_id', '<UNKNOWN>')
                      ))

        return 'reject', 'Service unavailable, blackholed.'

    return None, None


################
def run_tests():
    import unittest

    class Tests(unittest.TestCase):
        def test_is_loopback(self):
            self.assertEqual(is_loopback('10.1.1.1'), False)
            self.assertEqual(is_loopback('127.0.0.1'), True)
            self.assertEqual(is_loopback('::1'), True)

            try:
                import ipaddress
                #  tests using ipaddress module (if available)
                self.assertEqual(is_loopback('127.0.1.1'), True)
            except ImportError:
                pass

    suite = unittest.TestLoader().loadTestsFromTestCase(Tests)
    unittest.TextTestRunner(verbosity=2).run(suite)


###################
#  load config file
configFile = tumgreyspfsupp.defaultConfigFilename
if len(sys.argv) > 1:
    if '--test' in sys.argv[1:]:
        run_tests()
        sys.exit(0)

    if sys.argv[1] in ('-?', '--help', '-h'):
        print 'usage: tumgreyspf [<configfilename> | --test]'
        sys.exit(1)
    configFile = sys.argv[1]
configGlobal = tumgreyspfsupp.process_config_file(filename=configFile)

#  loop reading data
debugLevel = configGlobal.get('debugLevel', 0)
if debugLevel >= 2:
    syslog.syslog('Starting')
instance_list = []
data = {}
lineRx = re.compile(r'^\s*([^=\s]+)\s*=(.*)$')
while 1:
    line = sys.stdin.readline()
    if not line:
        break
    line = string.rstrip(line)
    if debugLevel >= 4:
        syslog.syslog('Read line: "%s"' % line)

    # end of entry
    if not line:
        if debugLevel >= 4:
            syslog.syslog('Found the end of entry')
        configData = tumgreyspfsupp.lookup_config(
            configGlobal.get('configPath'), data, configGlobal)
        if debugLevel >= 2:
            syslog.syslog('Config: %s' % str(configData))

        # run the checkers
        checkerValue = None
        checkerReason = None
        for checkerType in string.split(configData.get('CHECKERS', ''), ','):
            checkerType = string.strip(checkerType)

            if checkerType == 'greylist':
                checkerValue, checkerReason = greylist_check(data,
                                                             configData,
                                                             configGlobal)
                if checkerValue is not None:
                    break
            elif checkerType == 'spf':
                checkerValue, checkerReason = spf_check(data,
                                                        configData,
                                                        configGlobal)
                if configData.get('SPFSEEDONLY', 0):
                    checkerValue = None
                    checkerReason = None
                if checkerValue is not None and checkerValue != 'prepend':
                    break
            elif checkerType == 'blackhole':
                checkerValue, checkerReason = black_hole_check(data,
                                                               configData,
                                                               configGlobal)
                if checkerValue is not None:
                    break

        # handle results

        if checkerValue == 'reject':
            sys.stdout.write('action=550 %s\n\n' % checkerReason)

        elif checkerValue == 'prepend':
            instance = data.get('instance')
            # The following if is only needed for testing.  Postfix
            # will always provide instance.
            if not instance:
                import random

                instance = str(int(random.random() * 100000))
            # This is to prevent multiple headers being prepended
            # for multi-recipient mail.
            found_instance = instance_list.count(instance)
            if found_instance == 0:
                sys.stdout.write('action=prepend %s\n\n' % checkerReason)
                instance_list.append(instance)
            else:
                sys.stdout.write('action=dunno\n\n')
        elif checkerValue == 'defer':
            sys.stdout.write('action=defer_if_permit %s\n\n' % checkerReason)
        else:
            sys.stdout.write('action=dunno\n\n')

        # end of record
        sys.stdout.flush()
        data = {}
        continue

    # parse line
    m = lineRx.match(line)
    if not m:
        syslog.syslog('ERROR: Could not match line "%s"' % line)
        continue

    # save the string
    key = m.group(1)
    value = m.group(2)
    if key not in ['protocol_state', 'protocol_name', 'queue_id']:
        value = string.lower(value)
    data[key] = value
